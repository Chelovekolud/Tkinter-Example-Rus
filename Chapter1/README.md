# Создание окна

```cpp
#!/usr/bin/python
# -*- coding: utf-8 -*-

# импортирование модулей python
from tkinter import *

#создание окна
root = Tk()
root.title('myWindow')
root.geometry('200x150+300+225')

# вывод окна на экран
root.mainloop()
```        
Данный модуль Python [window_01.py](./window_01.py) создает пустое окно 200x150 с названием "myWindow", расположенное в центре экрана.

```cpp
#!/usr/bin/python
```
С этой строки начинается всякий исполняемый модуль Python [в Linux]. Символ # используется в Python для комментариев, так что интерпретатор строчку проигнорирует. Но в bash, базовом языке сценариев Linux, это не комментарий, и данная строка будет прочитана. В ней содержатся путь к интерпретатору python и указание исполнить код, записанный на Python. Такие инструкции называют "the pound bang" ["Pound" - "фунт" - так часто называют знак "#". "Bang" - сленговое название восклицательного знака "!"], и их ставят в каждой программе на первой строке. Можно забыть, для чего они нужны, но нельзя забывать вставлять их в код.

```cpp 
#импортирование модулей python
from tkinter import *
```
Данная строка загружает в Python весь модуль Tkinter целиком. В результате у Python появляется библиотека для построения оконного интерфейса.

```cpp
#создание окна
root = Tk()
root.title('myWindow')
root.geometry('200x150+300+225')
```
Tk() - это функция Tkinter, открывающая главное окно любого приложения. Здесь мы создаем экземпляр с именем root. Это общая черта всех классов Tkinter - они должны быть присвоены какой-либо переменной. В следующих двух командах задаются некоторые свойства root, определяющие заголовок и размеры окна. Это другой общий факт - взаимодействие с объектами Tkinter происходит через задание свойств [и вызов методов]. '200x150+300+225' означает [ширина x высота + координата_x_верхнего_левого_угла + координата_y_верхнего_левого_угла].

```cpp
#запуск окна
root.mainloop()
```
Наконец, в этой строке происходит вызов метода Tk() под названием mainloop(), который держит окно раскрытым, пока оно не будет закрыто нажатием кнопки [x] на окне или вызовом метода Tk() destroy().
> Экземпляры классов - это объекты, обладающие свойствами и методами. Объектно-ориентированные читатели уже знают об этом.

Довольно просто, не так ли? Понадобилось всего шесть строчек кода. Запустите Python; загрузите модуль Tkinter; присвойте какой-либо переменной значение Tk(); затем настройте три метода Tk() для этой переменной. Итак, запускаем [window_01.py](./window_01.py). Voila! Вы создали окно - фундаментальный элемент любого графического интерфейса пользователя Tkinter...

# Создание "дочернего" окна
```cpp
#!/usr/bin/python
# -*- coding: utf-8 -*-

# импортирование модулей python
from tkinter import *

#создание окна
root = Tk()
root.title('parent')
root.geometry('200x150+200+150')

#создание дочернего окна
child = Toplevel(root)
child.title('child')
child.geometry('200x150+400+300')

# запуск окна
root.mainloop()
```
          
Приведенный здесь модуль Python - [window_02.py](./window_02.py) помещает на экран еще одно пустое "дочернее" окно 200x150. В большинстве графических интерфейсов для организации диалога используют всплывающие окна. "Дочернее" окно исчезает при закрытии основного окна.
```cpp
# создание дочернего окна
child = Toplevel(root)
child.title('child')
child.geometry('200x150+400+300')
```
Toplevel() - это класс Tkinter, с помощью которого можно создавать любое окно кроме главного. Он также присваивается переменной child. Toplevel(root) означает дочернее окно child, относящееся и зависящее от родительского окна root. Следующие две команды формируют заголовок и размеры дочернего окна аналогично случаю родительского окна. Коду дочернего окна не нужен свой метод mainloop(). Он запускается из родительского окна.

Снова довольно просто. Потребовалось лишь три дополнительные строчки кода. Присвойте Toplevel() новой переменной; свяжите его с корневым окном root с помощью Toplevel(root); затем задайте значения пары свойств Toplevel(root). Наконец, запустите [window_02.py](./window_02.py).
Мы движемся быстро. Мы умеем создавать родительское окно и любое число дочерних окон. Закрытие родительского окна вызывает закрытие и окна дочернего, но не наоборот.

Уже похоже на интерфейс...

# Работа с классами
```cpp
#!/usr/bin/python
# -*- coding: utf-8 -*-

# импортирование модулей python
from tkinter import *

# класс родительских окон
class main:
  def __init__(self):
    self.master = root
    self.master.title('parent')
    self.master.geometry('200x150+200+150')
    child()
    self.master.mainloop()

# класс дочерних окон
class child:
  def __init__(self):
    self.slave = Toplevel(root)
    self.slave.title('child')
    self.slave.geometry('200x150+400+300')

# создание окна 
root = Tk() 

# запуск окна 
main()
```          
Python - это объектно-ориентированный язык программирования. Tk() и Toplevel() являются классами Tkinter, принимающими форму объектов для создания на экране графических окон. Программирование на Tkinter подразумевает комбинирование и преобразование встроенных классов Tkinter в новые классы с индивидуальными свойствами и методами.

Следующей задачей данного руководства будет воспроизведение визуального эффекта, достигнутого в последнем примере [window_02.py](./window_02.py), объектно-ориентированными средствами, заложенными в Python, т.е. путем создания классов. Приведенный выше код объявляет и определяет класс. Объект - это экземпляр класса. В данном случае мы собираемся создать простые классы родительских и дочерних окон. Позже мы будем формировать классы с их собственными (добавленными) свойствами и методами.

```cpp
# класс родительских окон
class main:
  def __init__(self):
    self.master = root
    self.master.title('parent')
    self.master.geometry('200x150+200+150')
    child()
    self.master.mainloop()
```

Вот обобщенная форма для создания классов. Замечание: отступы обязательны!

```cpp
  class {имя-класса}:
    def __init__(self):
      self.{переменная-класса} = ...
```

Здесь указывается, что будет создан класс с именем имя-класса со следующими определениями [def]. Команду __init__(self) проще показать в действии, чем объяснить. __init__() - это конструктор объектов, позволяющий создавать экземпляр объекта во время исполнения программы. self - это метка экземпляра, необходимая для привязки переменных класса к данному объекту. Таким образом инструкция self.master = root создает переменную master и присваивает ей глобальное значение root [пока еще не определенное]. В оставшейся части кода вы увидите, как теперь определяется то же самое окно внутри класса main. Итак, что же такое child()?

```cpp
# класс дочерних окон
class child:
  def __init__(self):
    self.slave = Toplevel(root)
    self.slave.title('child')
    self.slave.geometry('200x150+400+300')
```
child() - это вызов другого класса, определенного в модуле. Так класс main генерирует экземпляр дочернего окна.
```cpp
# создание окна
root = Tk()

# запуск окна
main()
```
При запуске модуля на выполнение происходит вызов Python, загрузка Tkinter и сохранение определений классов main и child. Команды, приведенные выше, сначала задают значение переменной root, чтобы создать экземпляр Tk(), затем открывают окно, активируя main [который, в свою очередь, активирует child]. Обратите внимание, что mainloop() расположен "внутри" класса main. Запустите [window_03.py](./window_03.py). Он должен сделать то же самое, что и предыдущий пример.

Если этот пример - ваша первая встреча с классами, объектами и т.п., в голову вполне может прийти мысль: "К чему такие сложности?" Но стоит нам перейти к более сложным примерам, как тотчас станет очевидно, что инкапсуляция кода внутрь классов - это отличный способ писать лаконичные, пригодные для многократного использования программы на Python. Потерпите немного. Некоторые из нас помнят, как учились составлять "макаронные" программы ['spaghetti' coding - слабо структурированные программы с большим размером процедур и интенсивным использованием оператора goto; трудны для изучения и модификаций], а потом изучали "структурное" программирование. Так что "объектно-ориентированное" программирование - это еще одна новинка...
